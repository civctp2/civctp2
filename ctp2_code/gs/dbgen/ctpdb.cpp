//----------------------------------------------------------------------------
//
// Project      : Call To Power 2
// File type    : C++ source
// Description  : Database generator
// Id           : $Id$
//
//----------------------------------------------------------------------------
//
// Disclaimer
//
// THIS FILE IS NOT GENERATED OR SUPPORTED BY ACTIVISION.
//
// This material has been developed at apolyton.net by the Apolyton CtP2
// Source Code Project. Contact the authors at ctp2source@apolyton.net.
//
//----------------------------------------------------------------------------
//
// Compiler flags
//
// _DEBUG
// - Generate debug version when set.
//
// HAVE_UNISTD_H
//
// WIN32
//
// _MAX_PATH
//
//----------------------------------------------------------------------------
//
// Modifications from the original Activision code:
//
// - Variable 'or' renamed, because this a reserved symbol (same as ||) now.
// - Modifed db_add_bit_pair function to allow bit pairs to have default
//   values so that when two records are merged, only the bit is merged
//   in that is set. - Sep. 28th 2004 Martin Gühmann
// - Portability improved (ctplinuxfan).
//
//----------------------------------------------------------------------------

#include "ctp2_config.h"
#include "ctp2_inttypes.h"

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if defined(HAVE_UNISTD_H)
#include <unistd.h>
#endif
#if defined(WIN32)
#include <windows.h>
#include <direct.h>
#else
#include "windows.h"
#endif
#include <time.h>
#include <errno.h>

#include "ctpdb.h"
#include "RecordDescription.h"

RecordDescription *g_record = NULL;

#ifndef _MAX_PATH
#if defined(PATH_MAX)
#define _MAX_PATH PATH_MAX
#else
#define _MAX_PATH 1024
#endif  // PATH_MAX
#endif  // _MAX_PATH

#ifndef FREAD_BUF_SIZE
#define FREAD_BUF_SIZE 16384
#endif

static char s_output_dir[_MAX_PATH];

static int copy_file(char *srcFName, char *dstFName)
{
	Assert(srcFName);
	Assert(dstFName);

	char buf[FREAD_BUF_SIZE];
	FILE *inFile = fopen(srcFName, "r");

	//Assert(inFile);
	if (!inFile)
		return -1;

	FILE *outFile = fopen(dstFName, "w");
	//Assert(outFile);
	if (!outFile) {
		fclose(inFile);
		return -1;
	}

#if defined(_MSC_VER) && (_MSC_VER <= 1200)
	int read;
	int wrote;
#else
	size_t read;
	size_t wrote;
#endif

	while ((read = fread((void *)&buf, sizeof(char),
	                     sizeof(buf) / sizeof(char), inFile
	                    )
	       ) > 0) {
		wrote = fwrite((void *)&buf, sizeof(char),
		               read, outFile);

	}

	fclose(outFile);
	fclose(inFile);

#if defined(_MSC_VER) && (_MSC_VER < 1200)
	if (0 >= read)
#else
	if (0 == read)
#endif
		return -1;

#if defined(_MSC_VER) && (_MSC_VER <= 1200)
	if (0 >= wrote)
#else
	if (0 == wrote)
#endif
		return -1;

	return 0;
}

void db_set_output_dir(char *dir)
{
	strncpy(s_output_dir, dir, _MAX_PATH);
}

static const char *db_get_code_directory()
{
	return s_output_dir;
}

void db_start_record(char *name)
{
	g_record = new RecordDescription(name);
}

FILE *db_open_file(const char *filename)
{
	FILE *outfile = fopen(filename, "w");

	Assert(outfile);
	if(!outfile)
		return NULL;

	fprintf(outfile, "\n/*\n");
	fprintf(outfile, " * DO NOT EDIT THIS FILE!\n");
	fprintf(outfile, " * It is generated automatically by ctpdb\n");
	fprintf(outfile, " */\n");

	return outfile;
}

bool db_files_differ(char *newFilePath, char *oldFilePath)
{
	FILE *n, *o;
	n = fopen(newFilePath, "r");
	if(!n) return true;

	o = fopen(oldFilePath, "r");
	if(!o) {
		fclose(n);
		return true;
	}

#define DIFF_SIZE FREAD_BUF_SIZE

	while(!feof(n) && !feof(o)) {
		char nb[DIFF_SIZE], ob[DIFF_SIZE];
		int const	nr      = fread(nb, 1, DIFF_SIZE, n);
		int const	oldr	= fread(ob, 1, DIFF_SIZE, o);

		if (nr != oldr) {
			fclose(n);
			fclose(o);
			return true;
		}
		sint32 i;
		for(i = 0; i < nr; i++) {
			if(nb[i] != ob[i]) {
				fclose(n);
				fclose(o);
				return true;
			}
		}
	}
	fclose(n);
	fclose(o);
	return false;
}
void db_maybe_copy(char *newFilePath)
{
	char oldpath[_MAX_PATH];
	getcwd(oldpath, _MAX_PATH);

	chdir(db_get_code_directory());

	char oldFilePath[_MAX_PATH];

	strcpy(oldFilePath, newFilePath);
	char *dot = strrchr(oldFilePath, '.');
	if(!dot) {
		chdir(oldpath);
		return;
	}
	*dot = 0;

	if(db_files_differ(oldFilePath, newFilePath)) {
		char backupPath[_MAX_PATH] = { 0 };
		sprintf(backupPath, "%s.old", oldFilePath);
#ifdef _DEBUG
		printf("%s -> %s\n", oldFilePath, backupPath);
#endif
		if (0 != copy_file(oldFilePath, backupPath)) {
		  fprintf(stderr, "%s\n", strerror(errno));
		}
#ifdef _DEBUG
		printf("%s -> %s\n", newFilePath, oldFilePath);
#endif
		if (0 != copy_file(newFilePath, oldFilePath)) {
		  fprintf(stderr, "%s\n", strerror(errno));
		}
	}
#if 0
	sprintf(cmd, "diff -q %s %s", oldFilePath, newFilePath);
	fprintf(stderr, "%s\n", cmd);
	fflush(stderr);
	FILE *diffOutput = _popen(cmd, "r");
	if(!diffOutput)
		fprintf(stderr, "Foo!\n");
	Assert(diffOutput);
	FILE *oldFile = fopen(oldFilePath, "r");
	if(!oldFile) {
		fclose(diffOutput);
		diffOutput = NULL;
	} else {
		fclose(oldFile);
	}

	if(!diffOutput) {
		fprintf(stderr, "Diff failed (not in path?), copying\n", newFilePath, oldFilePath);
		sprintf(cmd, "copy %s %s.old", oldFilePath, oldFilePath);
		system(cmd);
		sprintf(cmd, "copy %s %s", newFilePath, oldFilePath);
		system(cmd);
	} else {
		if(feof(diffOutput)) {
			fprintf(stderr, "No output\n");
		}
		while(!feof(diffOutput)) {
			line[0] = 0;
			fgets(line, 1024, diffOutput);
			fprintf(stderr, "%s\n", line);
			if(strstr(line, "differ") ||
			   strstr(line, "No such file or directory")) {
				fprintf(stderr, "%s and %s differ, copying\n", newFilePath, oldFilePath);
				sprintf(cmd, "copy %s %s.old", oldFilePath, oldFilePath);
				system(cmd);
				sprintf(cmd, "copy %s %s", newFilePath, oldFilePath);
				system(cmd);
				break;
			}
		}
	}
#endif
	unlink(newFilePath);

	chdir(oldpath);
}

void db_end_record(char *name)
{
	char filename[1024];
	FILE *outfile = NULL;

	sprintf(filename, "%s%s%sRecord.h.new",
	        db_get_code_directory(), FILE_SEP, name);

	outfile = db_open_file(filename);
	Assert(outfile);
	if(!outfile)
		return;

	g_record->ExportHeader(outfile);

	fclose(outfile);

	db_maybe_copy(strrchr(filename, FILE_SEPC) + 1);

	sprintf(filename, "%s%s%sRecord.cpp.new",
	        db_get_code_directory(), FILE_SEP, name);

	outfile = db_open_file(filename);
	Assert(outfile);
	if(!outfile)
		return;

	g_record->ExportCode(outfile);

	fclose(outfile);

	db_maybe_copy(strrchr(filename, FILE_SEPC) + 1);

	sprintf(filename, "%s%s%sRecord.stamp",
	        db_get_code_directory(), FILE_SEP, name);
	FILE *stamp = fopen(filename, "w");
	Assert(stamp);
	if(stamp) {
		fprintf(stamp, "//%d\n", time(0));
		fclose(stamp);
	}

	delete g_record;
	g_record = NULL;
}

void db_make_int_db(char *name)
{
	db_start_record(name);
	g_record->SetBaseType(DATUM_INT);
	db_end_record(name);
}

void db_make_float_db(char *name)
{
	db_start_record(name);
	g_record->SetBaseType(DATUM_FLOAT);
	db_end_record(name);
}

void db_make_string_db(char *name)
{
	db_start_record(name);
	g_record->SetBaseType(DATUM_STRING);
	db_end_record(name);
}

void db_make_string_id_db(char *name)
{
	db_start_record(name);
	g_record->SetBaseType(DATUM_STRINGID);
	db_end_record(name);
}

void db_start_member_class(char *name)
{
	Assert(g_record);
	g_record->StartMemberClass(name);
}

void db_end_member_class(char *name)
{
	Assert(g_record);
	g_record->EndMemberClass(name);
}

void db_add_bits(struct namelist *list, struct fieldsize *size)
{
	Assert(g_record);
	while(list) {
		g_record->AddDatum(DATUM_BIT, list, size->minSize, size->maxSize);
		struct namelist *next = list->next;
		free(list);
		list = next;
	}
}

void db_add_ints(struct namelist *list, struct fieldsize *size)
{
	Assert(g_record);
	while(list) {
		g_record->AddDatum(DATUM_INT, list, size->minSize, size->maxSize);
		struct namelist *next = list->next;
		free(list);
		list = next;
	}
}

void db_add_floats(struct namelist *list, struct fieldsize *size)
{
	Assert(g_record);
	while(list) {
		g_record->AddDatum(DATUM_FLOAT, list, size->minSize, size->maxSize);
		struct namelist *next = list->next;
		free(list);
		list = next;
	}
}

void db_add_records(char *recType, struct namelist *list, fieldsize *size)
{
	Assert(g_record);
	while(list) {
		g_record->AddDatum(DATUM_RECORD, list, size->minSize, size->maxSize,
						   recType);
		struct namelist *next = list->next;
		free(list);
		list = next;
	}
}

void db_add_structs(char *structType, struct namelist *list, fieldsize *size)
{
	Assert(g_record);
	while(list) {
		g_record->AddDatum(DATUM_STRUCT, list, size->minSize, size->maxSize,
						   structType);
		struct namelist *next = list->next;
		free(list);
		list = next;
	}
}

void db_add_filenames(struct namelist *list, fieldsize *size)
{
	Assert(g_record);
	while(list) {
		g_record->AddDatum(DATUM_FILE, list, size->minSize, size->maxSize);
		struct namelist *next = list->next;
		free(list);
		list = next;
	}
}

void db_add_strings(struct namelist *list, struct fieldsize *size)
{
	Assert(g_record);
	while(list) {
		g_record->AddDatum(DATUM_STRING, list, size->minSize, size->maxSize);
		struct namelist *next = list->next;
		free(list);
		list = next;
	}
}

void db_add_string_ids(struct namelist *list, struct fieldsize *size)
{
	Assert(g_record);
	while(list) {
		g_record->AddDatum(DATUM_STRINGID, list, size->minSize, size->maxSize);
		struct namelist *next = list->next;
		free(list);
		list = next;
	}
}

void db_add_bit_pair(struct namelist *list, struct fieldsize *size, struct bitpairtype *pairtype)
{
	Assert(g_record);
	while(list) {
// Added by Martin Gühmann
		g_record->AddBitPair(list, size->minSize, size->maxSize, pairtype);
		struct namelist *next = list->next;
		free(list);
		list = next;
	}
}

void db_add_grouped_bits(char *groupName, struct namelist *list)
{
	Assert(g_record);

	g_record->AddGroupedBits(groupName, list);
}
