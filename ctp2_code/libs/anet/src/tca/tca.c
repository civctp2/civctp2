/*
Copyright (C) 1995-2001 Activision, Inc.

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*/

/*--------------------------------------------------------------------------
  Trivial challenge authentication system.
--------------------------------------------------------------------------*/
#include <time.h>
#include <string.h>
#include <stdlib.h>
#include "dp2.h"		/* for DPRINT, etc. */
#include "contract.h"	/* for precondition() */
#include "tca.h"
#include "tcapw.h"
#include "eclock.h"
#include "mywcs.h"		/* extra wcs functions */
#define D2DES
#include "../3rdparty/d3des/d3des.h"
#include "../3rdparty/md5/global.h"		/* for md5 */
#include "../3rdparty/md5/md5.h"

/* Secret stuff the caller doesn't really need to know:
 *
 * MD5 is a secure hash function which reduces data to a 16 byte
 * message digest.  In this implimentation, WCS passwords passed to
 * MD5 have been been zero padded to the maximum length of 32 bytes.
 *
 * DES is the US Federal Government's Data Encryption Standard.
 * DES(k, d) takes a 8 byte key and encrypts an 8 byte data block.
 * Messages encrypted with it can be decrypted, given the key.
 *
 * A simple extension of DES is DESn.
 * DESn(k, d) takes a 8 byte key and an arbitrary length data block,
 * and divides up the data d into 8 byte chunks d1, d2... dn.
 * DESn(k, d) = concat(DES(k, d1), DES(k, d2), ... DES(k, dn)
 *
 * A simple extension of DESn is TDESn.
 * TDESn(k, d) divides up the key k into 8 byte chunks k1, k2, ...
 * plus a remainder kr, which is zero padded.
 * TDESn(k, d) = DES(kr, ... DES(k2, DES(k1, d))...)
 *
 * A tca_response_t is generated by encrypting the challenge with
 * TDESn, with a tcapw_hpw_t as key (i.e., the MD5 hash of the user's
 * password), then taking the MD5 hash of the result.
 * response(challenge) = MD5(TDESn(MD5(password), challenge))
 *
 * A tca_pwchange_t is a challenge response concatenated with the MD5
 * hash of the new password, all encrypted with TDESn, with a tcapw_hpw_t
 * as key (i.e., the MD5 hash of the user's old password).
 * pwchange = TDESn(MD5(oldpasswd), concat(response(challenge),MD5(newpasswd)))
 *
 * A tca_newuser_t is a new username, the hash of a new password, and
 * a magic string encrypted with TDESn, with the hash of the challenge
 * plus a second magic string as the key.  This is not very secure, but
 * the new user does not have a password registered with the server to
 * encrypt with.  Until we can legally export a public key system,
 * the best we can do is security through obscurity.
 * newuser(challenge) = TDESn(MD5(concat(challenge, magic2)),
 *                            concat(username, MD5(password), magic));
 *
 * End secret stuff.
 */

/*--------------------------------------------------------------------------
  Create an instance of the trivial challenge authenticator module.
  Called by both client and server.
  Returns NULL on failure.
--------------------------------------------------------------------------*/
tca_t *tca_create(void)
{
	tca_t *tca;

	if ((tca = (tca_t *) malloc(sizeof(tca_t))) == NULL)
		return (tca_t *)NULL;
	tca->tdb = tcapw_create();
	if (tca->tdb == NULL) {
		free(tca);
		return (tca_t *)NULL;
	}

	return tca;
}

/*--------------------------------------------------------------------------
  Load a password database from disk.
  Called only by server.
  Returns dp_RES_OK on success,
          dp_RES_EMPTY if fname was not found (not an error if you intend
		                to create a new database,
          dp_RES_BAD on bad args (NULL tca or tca->tdb).
--------------------------------------------------------------------------*/
dp_result_t tca_openpw(tca_t *tca, const char *fname)
{
	if (tca == NULL || fname == NULL)
		return dp_RES_BAD;
	return tcapw_open(tca->tdb, fname);
}

/*--------------------------------------------------------------------------
 Discard an instance of the trivial challenge authenticator module.
 Closes the password database if it is open.
 Called by both client and server.
 Returns dp_RES_OK on success,
         dp_RES_BAD if tca is bad (tca->tdb is NULL),
         dp_RES_ALREADY if tca is NULL already,
		 dp_RES_CANT_WRITE if the database could not be written to disk.
--------------------------------------------------------------------------*/
dp_result_t tca_destroy(tca_t *tca)
{
	dp_result_t err;

	if (tca == NULL)
		return dp_RES_ALREADY;
	err = tcapw_close(tca->tdb);
	if (err != dp_RES_OK && err != dp_RES_EMPTY /* No DB open */)
		DPRINT(("tca_destroy: can't write db, err:%d\n", err));
	else if (err == dp_RES_EMPTY)
		err = dp_RES_OK;  /* This is a normal condition on the client */
	tcapw_destroy(tca->tdb);
	memset(tca, 0, sizeof(tca_t));
	free(tca);
	return err;
}

/*--------------------------------------------------------------------------
 Freeze an instance of the trivial challenge authenticator module to disk.
 Freezes password database to disk as well.
 Returns dp_RES_OK on success,
 		 dp_RES_FULL on write failure.
--------------------------------------------------------------------------*/
dp_result_t tca_Freeze(tca_t *tca, FILE *fp)
{
	precondition(tca);
	precondition(fp);

	/* save the filename of the database in the freeze file */
	if (fwrite(tca->tdb->filename, 256, 1, fp) != 1)
		return dp_RES_FULL;
	return tcapw_close(tca->tdb);  /* save the password database */
}

/*--------------------------------------------------------------------------
 Thaw an instance of the trivial challenge authenticator module from disk.
 Loads the password database from disk as well.
 Returns dp_RES_OK on success,
 		 dp_RES_EMPTY on read failure.
--------------------------------------------------------------------------*/
dp_result_t tca_Thaw(tca_t *tca, FILE *fp)
{
	char filename[256];

	precondition(tca);
	precondition(fp);

	/* read the filename of the database from the freeze file */
	if (fread(filename, 256, 1, fp) != 1)
		return dp_RES_EMPTY;
	return tca_openpw(tca, filename);
}

/*--------------------------------------------------------------------------
  Look up a user's uid from his name.
  Called by both client and server.
  Returns uid on success,
          tcapw_UID_NONE on failure.
--------------------------------------------------------------------------*/
tcapw_uid_t tca_uname2uid(tca_t *tca, const tcapw_uname_t *uname)
{
	dp_result_t err;
	tcapw_entry_t entry;

	if (tca == NULL)
		return tcapw_UID_NONE;
   	if ((err = tcapw_entry_find_byname(tca->tdb, uname, &entry)) != dp_RES_OK)
		return tcapw_UID_NONE;
	return entry.uid;
}

/*--------------------------------------------------------------------------
 Look up a user's uname from his uid.
 Called by both client and server.
 Returns dp_RES_OK on success,
         dp_RES_EMPTY if uid does not exist,
		 dp_RES_BAD on bad args.
--------------------------------------------------------------------------*/
dp_result_t tca_uid2uname(tca_t *tca, tcapw_uid_t uid, tcapw_uname_t *uname)
{
	dp_result_t err;
	tcapw_entry_t entry;

	if (tca == NULL)
		return dp_RES_BAD;
	if ((err = tcapw_entry_find_byid(tca->tdb, uid, &entry)) != dp_RES_OK)
		return err;
	memcpy(uname, &(entry.uname), sizeof(tcapw_uname_t));
	return dp_RES_OK;
}

/*--------------------------------------------------------------------------
  Generate a new challenge.
  Called by server.
  Challenge stored in the given buffer.
  No two challenges are ever the same.
  Returns dp_RES_OK on success,
          dp_RES_BAD on bad args.
--------------------------------------------------------------------------*/
dp_result_t tca_challenge_generate(tca_t *tca, tca_challenge_t *challenge)
{
	MD5_CTX context;
	time_t ctime;   /* calendar time */
	clock_t ptime;  /* processor time (obviously not independant of ctime) */
	unsigned long rnd[3];
	unsigned long l;
	unsigned char c[8];
	unsigned char digest[16];

	if (tca == NULL || challenge == NULL)
		return dp_RES_BAD;

	time(&ctime);             /* 32 bits, some very slow to change */
	ptime = eclock();
	ptime &= 0x000003ff;      /* smallest 10 bits (1024 ECLOCKS) are independant of ctime */
	rnd[0] = rand() & 0x7f;   /* 7 bits  (should call srand()) at some point */
	rnd[1] = rand() & 0x7f;   /* 7 bits */
	rnd[2] = rand() & 0x7f;   /* 7 bits */
	l = ((unsigned long)ptime) | (rnd[0] << 10) | (rnd[1] << 17) | (rnd[0] << 24);

	memcpy(c, &ctime, 4);  /* if time_t and long are not 4 bytes, this might lose important bits */
	memcpy(&c[4], &l, 4);

	MD5Init(&context);
	MD5Update(&context, c, 8);           /* MD5 the varying string */
	MD5Update(&context, "n|jB^d7?", 8);  /* add constant string to confuse things further */
	MD5Final(digest, &context);

	memcpy(challenge->challenge, digest, tca_LEN_CHALLENGE);
	DPRINT(("tca_challenge_generate: %s\n", tcapw_hexprint(challenge->challenge, tca_LEN_CHALLENGE)));
	return dp_RES_OK;
}

/*--------------------------------------------------------------------------
  Check a user's response to a challenge generated by tca_challenge_generate.
  Returns the user's uid into the tcapw_uid_t pointed to by uid.
  Called by server.
  Returns dp_RES_OK on success,
          dp_RES_ACCESS if the response was invalid,
		  dp_RES_EMPTY if the uid does not exist,
		  dp_RES_BAD on bad args.
--------------------------------------------------------------------------*/
dp_result_t tca_response_validate(tca_t *tca, const tca_challenge_t *challenge, const tca_response_t *response, tcapw_uid_t *uid)
{
	MD5_CTX context;
	dp_result_t err;
	tcapw_uname_t uname;
	tcapw_entry_t entry;
	unsigned char buf[tca_LEN_CHALLENGE];
	char correct_response[tca_LEN_RESPONSE];

	if (tca == NULL || challenge == NULL || response == NULL || uid == NULL) {
		DPRINT(("tca_response_validate: bad arguments\n"));
		return dp_RES_BAD;
	}

	*uid = tcapw_UID_NONE;
	memset(&uname, 0, sizeof(tcapw_uname_t));
	DPRINT(("tca_response_validate: challenge %s uname %s\n", tcapw_hexprint(challenge->challenge, tca_LEN_CHALLENGE), tcapw_u2ascii(response->uname, response->unamelen)));
	mywcs_ncpy0(uname.uname, response->uname, response->unamelen);
	if((err = tcapw_entry_find_byname(tca->tdb, &uname, &entry)) != dp_RES_OK) {
		DPRINT(("tca_response_validate: find_byname failed, err:%d\n", err));
		return err;
	}
	DPRINT(("tca_response_validate: hpw %s\n", tcapw_hexprint(entry.hpw.hpw, tcapw_LEN_HASHPW)));
	DPRINT(("tca_response_validate: response %s\n", tcapw_hexprint(response->response, tca_LEN_RESPONSE)));

	desDkey(entry.hpw.hpw, EN0);
	Ddes(challenge->challenge, buf);

	MD5Init(&context);
	MD5Update(&context, buf, tca_LEN_CHALLENGE);
	MD5Final(correct_response, &context);

	if (memcmp(response->response, correct_response, tca_LEN_RESPONSE)) {
		DPRINT(("tca_response_validate:       != %s\n", tcapw_hexprint(correct_response, tca_LEN_RESPONSE)));
		return dp_RES_ACCESS;
	}
	*uid = entry.uid;
	return dp_RES_OK;
}

/*--------------------------------------------------------------------------
  Generate a response for a challenge.
  Called by client.
  On entry, response points to a buffer of size sizeof(tca_response_t),
            responselen points to an uninitialized integer.
  On success, response points to a filled response struct
              responselen points to the total used size of the struct.
  Returns dp_RES_OK on success,
          dp_RES_BAD on bad args.
--------------------------------------------------------------------------*/
dp_result_t tca_response_generate(tca_t *tca, const tca_challenge_t *challenge, const tcapw_uname_t *username, const tcapw_hpw_t *hpw, tca_response_t *response, int *responselen)
{
    MD5_CTX context;
	unsigned char buf[tca_LEN_CHALLENGE];

	if (tca == NULL || challenge == NULL || username == NULL || hpw == NULL || response == NULL || responselen == NULL)
		return dp_RES_BAD;

  	desDkey(hpw->hpw, EN0);
	Ddes(challenge->challenge, buf);

	MD5Init(&context);
	MD5Update(&context, buf, tca_LEN_CHALLENGE);
	MD5Final(response->response, &context);

	response->unamelen = mywcs_ncpy0(response->uname, username->uname, tcapw_LEN_USERNAME);
	DPRINT(("tca_response_generate: challenge %s uname %s\n", tcapw_hexprint(challenge->challenge, tca_LEN_CHALLENGE), tcapw_u2ascii(response->uname, tcapw_LEN_USERNAME)));
	DPRINT(("tca_response_generate: hpw %s\n", tcapw_hexprint(hpw->hpw, tcapw_LEN_HASHPW)));
	DPRINT(("tca_response_generate: response %s\n", tcapw_hexprint(response->response, tca_LEN_RESPONSE)));

	/* packet length is max length minus unused characters in uname */
	*responselen = sizeof(*response) - (tcapw_LEN_USERNAME - response->unamelen)*sizeof(short);
	return dp_RES_OK;
}

/*--------------------------------------------------------------------------
  Generate a password or email change request.
  Called by client.
  Just like a normal response, but also contains the desired new password,
  email, and flags from tcapw_entry_FLAGS_*.
  Returns dp_RES_OK on success,
          dp_RES_BAD on bad args.
--------------------------------------------------------------------------*/
dp_result_t tca_pwchange_generate(tca_t *tca, const tca_challenge_t *challenge, const tcapw_hpw_t *oldhpw, const tcapw_hpw_t *newhpw, int flags, const char *email, tca_pwchange_t *pwchange, int *pwchangelen)
{
	MD5_CTX context;
	tca_response_t response;
	unsigned char buf[tca_LEN_CHALLENGE];

	if (tca == NULL || challenge == NULL || oldhpw == NULL || newhpw == NULL || pwchange == NULL || email == NULL)
		return dp_RES_BAD;

	DPRINT(("tca_pwchange_generate: challenge %s flags %d email %s\n", tcapw_hexprint(challenge->challenge, tca_LEN_CHALLENGE), flags, email));
	DPRINT(("tca_pwchange_generate: hpw %s\n", tcapw_hexprint(oldhpw->hpw, tcapw_LEN_HASHPW)));
	DPRINT(("tca_pwchange_generate: newhpw %s\n", tcapw_hexprint(newhpw->hpw, tcapw_LEN_HASHPW)));

	pwchange->emaillen = strlen(email);
	if (pwchange->emaillen > tcapw_MAXLEN_EMAIL)
		pwchange->emaillen = tcapw_MAXLEN_EMAIL;
	strncpy(pwchange->email, email, tcapw_MAXLEN_EMAIL);
	pwchange->flags = flags;

  	desDkey(oldhpw->hpw, EN0);
	Ddes(challenge->challenge, buf);

	MD5Init(&context);
	MD5Update(&context, buf, tca_LEN_CHALLENGE);
	MD5Final(response.response, &context);

	DPRINT(("tca_pwchange_generate: response %s\n", tcapw_hexprint(response.response, tca_LEN_RESPONSE)));

	D2des(response.response, pwchange->pwchange);
	D2des(newhpw->hpw, &(pwchange->pwchange[tca_LEN_RESPONSE]));

	/* packet length is max length minus unused characters in email */
	*pwchangelen = sizeof(*pwchange) - (tcapw_MAXLEN_EMAIL - pwchange->emaillen)*sizeof(char);
	return dp_RES_OK;
}

/*--------------------------------------------------------------------------
  Change the user's entry if the challenge response contained in pwchange
  is valid.
  Called by server.
  Returns dp_RES_OK on success,
          dp_RES_ACCESS if the response was invalid,
		  dp_RES_BUG if the password change failed,
		  dp_RES_BAD on bad args.
--------------------------------------------------------------------------*/
dp_result_t tca_pwchange_validate(tca_t *tca, tcapw_uid_t uid, const tca_challenge_t *challenge, const tca_pwchange_t *pwchange)
{
	MD5_CTX context;
	dp_result_t err;
	tca_response_t response;
	tcapw_entry_t entry;
	tcapw_hpw_t newhpw;
	char correct_response[tca_LEN_RESPONSE];
	unsigned char buf[tca_LEN_RESPONSE];  /* tca_LEN_RESPONSE >= tcapw_LEN_HASHPW */
	char email[tcapw_MAXLEN_EMAIL];
	int flags;

	if (tca == NULL || challenge == NULL || uid == tcapw_UID_NONE || pwchange == NULL)
		return dp_RES_BAD;
	if((err = tcapw_entry_find_byid(tca->tdb, uid, &entry)) != dp_RES_OK)
		return err;

	/* validate him using the response part of pwchange */
	/* construct the correct response */
	desDkey(entry.hpw.hpw, EN0);
	Ddes(challenge->challenge, buf);

	MD5Init(&context);
	MD5Update(&context, buf, tca_LEN_CHALLENGE);
	MD5Final(correct_response, &context);

	/* decrypt his response */
	memcpy(buf, pwchange->pwchange, tca_LEN_RESPONSE);
	desDkey(entry.hpw.hpw, DE1);
	D2des(buf, response.response);

	DPRINT(("tca_pwchange_validate: challenge %s\n", tcapw_hexprint(challenge->challenge, tca_LEN_CHALLENGE)));
	DPRINT(("tca_pwchange_validate: hpw %s\n", tcapw_hexprint(entry.hpw.hpw, tcapw_LEN_HASHPW)));
	DPRINT(("tca_pwchange_validate: response %s\n", tcapw_hexprint(response.response, tca_LEN_RESPONSE)));

	if (memcmp(response.response, correct_response, tca_LEN_RESPONSE)) {
		DPRINT(("tca_pwchange_validate:       != %s\n", tcapw_hexprint(correct_response, tca_LEN_RESPONSE)));
		return dp_RES_ACCESS;
	}
	/* extract email, flags, and hash of password, then make the change */
	strncpy(email, pwchange->email, tcapw_MAXLEN_EMAIL);
	email[pwchange->emaillen] = '\0';
	/* caller can only set client settable flags, others are unchanged */
	flags = ((pwchange->flags & tcapw_entry_CLIENT_SET_FLAGS) |
			 (entry.flags & ~tcapw_entry_CLIENT_SET_FLAGS));
	memcpy(buf, &(pwchange->pwchange[tca_LEN_RESPONSE]), tcapw_LEN_HASHPW);
	D2des(buf, newhpw.hpw);

	DPRINT(("tca_pwchange_validate: flags %d email %s newhpw %s\n", flags, email, tcapw_hexprint(newhpw.hpw, tcapw_LEN_HASHPW)));

	return tcapw_entry_change(tca->tdb, uid, &newhpw, flags, email);
}

const unsigned char newuser_magic[9] = "^Ct:vN3[";
const unsigned char newuser_magic2[9] = "o35(v&:T";

/*--------------------------------------------------------------------------
  Generate a newuser request.
  Called by client.
  The newuser packet contains the desired new username, email, hashed
  password, and flags from tcapw_entry_FLAGS_*.
  On entry, newuser points to a buffer of size sizeof(tca_newuser_t),
            newuserlen points to an uninitialized integer.
  On success, newuser points to a filled newuser struct
              newuserlen points to the total used size of the struct.
  Returns dp_RES_OK on success,
          dp_RES_BAD on bad args.
--------------------------------------------------------------------------*/
dp_result_t tca_newuser_generate(tca_t *tca, const tca_challenge_t *challenge, const tcapw_uname_t *newusername, const tcapw_hpw_t *newhpw, int flags, const char *email, tca_newuser_t *newuser, int *newuserlen)
{
	MD5_CTX context;
	unsigned char buf[16];

	if (tca == NULL || challenge == NULL || newusername == NULL || newhpw == NULL || newuser == NULL || newuserlen == NULL || email == NULL)
		return dp_RES_BAD;

	DPRINT(("tca_newuser_generate: challenge %s uname %s flags %d email %s\n", tcapw_hexprint(challenge->challenge, tca_LEN_CHALLENGE), tcapw_u2ascii(newusername->uname, tcapw_LEN_USERNAME), flags, email));
	DPRINT(("tca_newuser_generate: hpw %s\n", tcapw_hexprint(newhpw->hpw, tcapw_LEN_HASHPW)));

	/* Kludge for lack of a distributable PGP style public key system:
	 * Just encrypt the MD5(newpassword) and a magic string with
	 * MD5(another magic string + the challenge that the server just sent)
	 * as the key.
	 */
	newuser->unamelen = mywcs_ncpy0((short *)newuser->storage, newusername->uname, tcapw_LEN_USERNAME);
	newuser->emaillen = strlen(email);
	newuser->flags = flags;
	if (newuser->emaillen > tcapw_MAXLEN_EMAIL)
		newuser->emaillen = tcapw_MAXLEN_EMAIL;
	strncpy(newuser->storage + newuser->unamelen * sizeof(short), email, tcapw_MAXLEN_EMAIL);

	MD5Init(&context);
	MD5Update(&context, newuser_magic2, 8);
	MD5Update(&context, challenge->challenge, tca_LEN_CHALLENGE);
	MD5Final(buf, &context);

	desDkey(buf, EN0);
	D2des(newhpw->hpw, newuser->newuser);
	Ddes(newuser_magic, &(newuser->newuser[tcapw_LEN_HASHPW]));

	DPRINT(("tca_newuser_generate: newuser %s\n", tcapw_hexprint(newuser->newuser, tcapw_LEN_HASHPW)));

	/* packet length is max length minus unused characters in uname, email */
	*newuserlen = sizeof(*newuser) - (tcapw_LEN_USERNAME - newuser->unamelen)*sizeof(short) - (tcapw_MAXLEN_EMAIL - newuser->emaillen)*sizeof(char);
	return dp_RES_OK;
}

/*--------------------------------------------------------------------------
  Create a new user with the username and password contained in newuser
  if the challenge response contained in newuser is valid.
  Returns the user's uid into the tcapw_uid_t pointed to by uid.
  Called by server.
  Returns dp_RES_OK on success,
          dp_RES_ACCESS if the response was invalid,
		  dp_RES_ALREADY if the username is in use,
		  dp_RES_BUG if the user creation failed for another reason,
		  dp_RES_BAD on bad args.
--------------------------------------------------------------------------*/
dp_result_t tca_newuser_validate(tca_t *tca, const tca_challenge_t *challenge, tca_newuser_t *newuser, tcapw_uid_t *uid)
{
	MD5_CTX context;
	tcapw_hpw_t hpw;
	tcapw_uname_t uname;
	unsigned char buf[16];
	unsigned char test_magic[8];
	char email[tcapw_MAXLEN_EMAIL + 1];
	int flags;

	if (tca == NULL || challenge == NULL || newuser == NULL || uid == NULL)
		return dp_RES_BAD;

	DPRINT(("tca_newuser_validate: challenge %s\n", tcapw_hexprint(challenge->challenge, tca_LEN_CHALLENGE)));
	DPRINT(("tca_newuser_validate: newuser %s\n", tcapw_hexprint(newuser->newuser, tcapw_LEN_HASHPW)));

	*uid = tcapw_UID_NONE;
	MD5Init(&context);
	MD5Update(&context, newuser_magic2, 8);
	MD5Update(&context, challenge->challenge, tca_LEN_CHALLENGE);
	MD5Final(buf, &context);

	memset(test_magic, 0, 8);
	desDkey(buf, DE1);
	D2des(newuser->newuser, hpw.hpw);
	Ddes(&(newuser->newuser[tcapw_LEN_HASHPW]), test_magic);

	if (memcmp(test_magic, newuser_magic, 8)) {
		DPRINT(("tca_newuser_validate: wrong magic %s \n", tcapw_hexprint(test_magic, 8)));
		return dp_RES_ACCESS;
	}

	/* the magic matches, so try to add the user */
	memset(&uname, 0, sizeof(tcapw_uname_t));
	mywcs_ncpy0(uname.uname, (short *)newuser->storage, newuser->unamelen);
	strncpy(email, newuser->storage + newuser->unamelen * sizeof(short), tcapw_MAXLEN_EMAIL);
	email[newuser->emaillen] = '\0';
	/* caller can only set client settable flags */
	/*** Server only flags default to 0, currently! ***/
	flags = newuser->flags & tcapw_entry_CLIENT_SET_FLAGS;

	DPRINT(("tca_newuser_validate: uname %s flags %d email %s\n", tcapw_u2ascii(uname.uname, tcapw_LEN_USERNAME), flags, email));
	DPRINT(("tca_newuser_generate: hpw %s\n", tcapw_hexprint(hpw.hpw, tcapw_LEN_HASHPW)));

	return tcapw_entry_create(tca->tdb, &uname, &hpw, flags, email, uid);
}

/*--------------------------------------------------------------------------
  Check a user's email validating secret code response to a challenge
  generated by tca_challenge_generate.
  Called by server.
  Returns dp_RES_OK on success,
          dp_RES_ACCESS if the response was invalid,
		  dp_RES_EMPTY if the uid does not exist,
		  dp_RES_BAD on bad args.
--------------------------------------------------------------------------*/
dp_result_t tca_secretcode_validate(tca_t *tca, tcapw_uid_t uid, const tca_challenge_t *challenge, const tca_response_t *response)
{
	MD5_CTX context;
	dp_result_t err;
	tcapw_entry_t entry;
	unsigned char buf[tca_LEN_CHALLENGE];
	char correct_response[tca_LEN_RESPONSE];
	tcapw_pw_t pw;
	tcapw_hpw_t hpw;

	if (tca == NULL || challenge == NULL || response == NULL || uid == tcapw_UID_NONE) {
		DPRINT(("tca_secrecode_validate: bad arguments\n"));
		return dp_RES_BAD;
	}

	DPRINT(("tca_secretcode_validate: challenge %s uid %d\n", tcapw_hexprint(challenge->challenge, tca_LEN_CHALLENGE), uid));
	if((err = tcapw_entry_find_byid(tca->tdb, uid, &entry)) != dp_RES_OK) {
		DPRINT(("tca_secretcode_validate: find_byid failed, err:%d\n", err));
		return err;
	}
	DPRINT(("tca_secretcode_validate: secretcode %d\n", entry.secretcode));

	tcapw_get_secretcode(&entry, pw.pw);
	tcapw_password_hash(tca->tdb, &pw, &hpw);
	DPRINT(("tca_secretcode_validate: hpw %s\n", tcapw_hexprint(hpw.hpw, tcapw_LEN_HASHPW)));
	DPRINT(("tca_secretcode_validate: response %s\n", tcapw_hexprint(response->response, tca_LEN_RESPONSE)));

	desDkey(hpw.hpw, EN0);
	Ddes(challenge->challenge, buf);

	MD5Init(&context);
	MD5Update(&context, buf, tca_LEN_CHALLENGE);
	MD5Final(correct_response, &context);

	if (memcmp(response->response, correct_response, tca_LEN_RESPONSE)) {
		DPRINT(("tca_secretcode_validate:       != %s\n", tcapw_hexprint(correct_response, tca_LEN_RESPONSE)));
		return dp_RES_ACCESS;
	}
	return dp_RES_OK;
}
